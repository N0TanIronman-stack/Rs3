<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Alt1 Stats Reader v1.6</title>
  <script src="https://alt1lib.com/dist/alt1lib.js"></script>
  <script src="https://www.unpkg.com/alt1/dist/ocr/index.js"></script>
  <style>
    body { font-family: Arial, sans-serif; background:#111; color:#eee; }
    #output { margin-top: 10px; }
  </style>
</head>
<body>
  <h2>Alt1 Stats Reader v1.6</h2>
  <div id="output">Waiting for Alt1…</div>

<script>
let statAnchorData, statBorderData, statRoofData;

function loadImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(a1lib.ImageData.fromImage(img));
    img.onerror = reject;
    img.src = url;
  });
}

Promise.all([
  loadImage("./statanchor.png"),
  loadImage("./statborder.png"),
  loadImage("./statroof.png")
]).then(([anchor, border, roof]) => {
  statAnchorData = anchor;
  statBorderData = border;
  statRoofData = roof;
  startScan();
});

function startScan() {
  setInterval(scanOnce, 400); // faster refresh
}

function scanOnce() {
  const screen = a1lib.captureHoldFullRs();
  const pos = screen.findSubimage(statAnchorData);
  if (!pos.length) {
    document.getElementById("output").innerText = "Stat anchor not found ❌";
    return;
  }
  const anchor = pos[0];
  const rect = findEdges(anchor.x, anchor.y, screen);
  a1lib.overlay.clear();
  a1lib.overlay.rect(a1lib.mixColor(0,0,255), rect.x, rect.y, rect.w, rect.h, 2);
  document.getElementById("output").innerText =
    `Stat window detected at X:${rect.x}, Y:${rect.y}, W:${rect.w}, H:${rect.h} ✅`;
}

function matchesIconAt(x0, y0, icon, screen, threshold=0.85) {
  const iw = icon.width, ih = icon.height;
  if (x0 < 0 || y0 < 0 || x0+iw > screen.width || y0+ih > screen.height) return false;

  const iconPix = icon.data;
  const screenPix = screen.data;
  let match = 0, total = iw*ih;

  for (let iy=0; iy<ih; iy+=2) { // step 2px for speed
    for (let ix=0; ix<iw; ix+=2) {
      const si = 4*((x0+ix)+(y0+iy)*screen.width);
      const ii = 4*(ix+iy*iw);
      if (Math.abs(screenPix[si]-iconPix[ii])<30 &&
          Math.abs(screenPix[si+1]-iconPix[ii+1])<30 &&
          Math.abs(screenPix[si+2]-iconPix[ii+2])<30) {
        match++;
      }
    }
  }
  return (match / (total/4)) >= threshold; // adjust denominator for step size
}

function findEdges(ax, ay, screen) {
  let leftX=ax, rightX=ax+statAnchorData.width;
  let topY=ay, bottomY=ay+statAnchorData.height;

  // Left edge
  let consec=0;
  for (let dx=1; dx<=500; dx+=2) {
    if (matchesIconAt(ax-dx, ay, statBorderData, screen)) {
      consec++;
      if (consec>=2) { leftX=ax-dx; break; }
    } else consec=0;
  }

  // Right edge
  consec=0;
  for (let dx=1; dx<=500; dx+=2) {
    if (matchesIconAt(ax+statAnchorData.width+dx, ay, statBorderData, screen)) {
      consec++;
      if (consec>=2) {
        rightX=ax+statAnchorData.width+dx+statBorderData.width;
        break;
      }
    } else consec=0;
  }

  // Top edge
  for (let dy=1; dy<=200; dy+=2) {
    if (matchesIconAt(ax, ay-dy, statRoofData, screen)) {
      topY=ay-dy;
      break;
    }
  }

  // Height: stop at bottom of icon + safe margin
  bottomY=ay+statAnchorData.height+200;

  // Clamp reasonable size
  const w=Math.min(Math.max(rightX-leftX,150),450);
  const h=Math.min(Math.max(bottomY-topY,100),500);

  return {x:leftX, y:topY, w:w, h:h};
}
</script>
</body>
</html>
